fn main() {
    // Sync and Send Traits
    // Send marker 特征指示实施 Send 类型的值的所有权可以在线程之间转移。几乎所有 Rust 类型都是 Send
    // 完全由 Send 类型组成的任何类型也会自动标记为 Send。

    // Sync marker trait 表示它对于实现 sync 以从多个线程引用。换句话说，任何类型 T 都是 Sync if &T （对 T 的不可变引用） 为 Send，
    // 这意味着该引用可以安全地发送到另一个线程。与 Send 类似，原始类型是 Sync 和完全由 Sync 类型组成的类型也是 Sync。

    // 1. Send 和 Sync 的基本含义
    //  Send
    //      含义：Send 表示一个类型的所有权可以安全地从一个线程转移到另一个线程。
    //      核心思想：如果一个类型实现了 Send，说明它在被移动到另一个线程时不会导致未定义行为或数据竞争。
    //  Sync
    //      含义：Sync 表示一个类型可以安全地被多个线程同时访问（共享访问）。
    //      核心思想：如果一个类型实现了 Sync，说明它的共享引用（&T）可以安全地在多个线程之间共享。
    // 2. Send 和 Sync 的实现规则
    //      自动实现
    //           Rust 编译器会自动为大部分类型实现 Send 和 Sync。
    //           如果一个类型的组成部分都实现了 Send 或 Sync，则该类型也会自动实现相应的特性。
    //      手动实现 你也可以手动实现 Send 和 Sync，但需要非常谨慎，因为错误的实现会导致未定义行为。
    // 3. Send 和 Sync 的用途
    //      用于线程安全的并发
    //      Send 用于确保线程间转移所有权是安全的。
    //      Sync 用于确保多个线程可以安全地共享数据。
    // 4. Send 和 Sync 的关系
    //      互相推导
    //      如果一个类型实现了 Send，通常也会实现 Sync，反之亦然。
    //      但并不是所有类型都同时实现两者，这取决于类型的具体实现。
    //      区别
    //      Send 关注的是所有权的转移。
    //      Sync 关注的是共享访问的安全性。
}
